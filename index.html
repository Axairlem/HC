<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>HardonCollider - A collision detection library</title>
<link rel="stylesheet" type="text/css" href="style.css" />
<link rel="stylesheet" type="text/css" href="highlight.css" />
<script type="text/javascript" src="highlight.pack.js"></script>
<script type="text/javascript">
	window.onload = function() {
		var examples = document.getElementsByTagName("code");
		for (i = 0; i < examples.length; ++i) {
			if (examples[i].className == "lua")
				hljs.highlightBlock(examples[i], "    ");
		}
	};
</script>
</head>

<body><a name="top"></a>
<a href="http://github.com/vrld/HardonCollider"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub" /></a>

<div id="header">
	<h1>Hardon Collider <span class="small">Collision detection for <a href="http://www.love2d.org/">L&Ouml;VE</a></span></h1>
	<ul id="nav">
		<li><a href="#init">Main Module</a></li>
		<li><a href="#shape">Shapes</a></li>
		<li><a href="#polygon">Polygon</a></li>
		<li><a href="#spatialhash">Spatial Hash</a></li>
	</ul>
	<h2>Reference pages</h2>
</div>

<a name="init"></a>
<div id="hardoncollider" class="module">
	<div class="name">hardoncollider<a class="top" href="#top">^ top</a></div>
	<div class="preamble">
		<p>The main module.</p>
		<p>HardonCollider will automatically handle - but not resolve - collisions.
		It uses search data structure - a spatial hash - to quickly find colliding shapes.</p>
		<p>A spatial hash is simply a grid that is laid over the whole scene in which a shape can occupy
		several cells. To find shapes that may be colliding, you simply need to look which shapes occupy
		the same cell. You can specify the cell size in the <code>init</code> function.</p>
		<p>To get a less boring explanation on how to use this, see the tutorial (once it's there).</p>
	</div>

	<div class="overview">
		<h3>Module overview</h3>
		<dl>
			<dt><a href="#init-init">init()</a></dt>
			<dd>Initialize module.</dd>
			<dt><a href="#init-setCallbacks">setCallbacks()</a></dt>
			<dd>Set callback functions.</dd>
			<dt><a href="#init-update">update()</a></dt>
			<dd>Update collision detection.</dd>
			<dt><a href="#init-addPolygon">addPolygon()</a></dt>
			<dd>Add polygon to the scene.</dd>
			<dt><a href="#init-addRectangle">addRectangle()</a></dt>
			<dd>Add rectangle to the scene.</dd>
			<dt><a href="#init-addCircle">addCircle()</a></dt>
			<dd>Add circle to the scene.</dd>
			<dt><a href="#remove">remove()</a></dt>
			<dd>Remove shape from scene.</dd>
			<dt><a href="#addToGroup">addToGroup()</a></dt>
			<dd>Group shapes that should not collide.</dd>
			<dt><a href="#removeFromGroup">removeFromGroup()</a></dt>
			<dd>Remove shape from a group.</dd>
			<dt><a href="#setGhost">setGhost()</a></dt>
			<dd>Stops shape from colliding.</dd>
			<dt><a href="#setSolid">setSolid()</a></dt>
			<dd>Make shape subject to collision again.</dd>
		</dl>
	</div>

	<a name="init-init"></a>
	<div id="init-init" class="function">
		<div class="definition">function <span class="name">init</span><span class="arglist">(cell_size, callback_start, callback_persist, callback_stop)</span><a class="top" href="#init">^ top</a></div>
		<p>Initializes the library. Call this in love.load(). All the parameters can be omitted.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>number <code>cell_size</code> (100)</dt>
				<dd>Cell size for internal search structure.</dd>
				<dt>function <code>callback_start</code> (empty function)</dt>
				<dd>Called when two shapes start colliding.</dd>
				<dt>function <code>callback_persist</code> (empty function)</dt>
				<dd>Called when two continue to collide, i.e. if the collision lasts more than one frame.</dd>
				<dt>function <code>callback_stop</code> (empty function)</dt>
				<dd>Called when two shapes stop colliding.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>Nothing</dt>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">function love.load()
    hardoncollider.init(150)
end</code></pre>
		</div>
	</div>

	<a name="init-setCallbacks"></a>
	<div id="setCallbacks" class="function">
		<div class="definition">function <span class="name">setCallbacks</span><span class="arglist">(start,persist,stop)</span><a class="top" href="#init">^ top</a></div>
		<div class="definition">function <span class="name">setCallbacks</span><span class="arglist">{start = start,persist = persist,stop = stop}</span></div>
		<p>Sets the different callbacks. The second calling style let's you specify the callbacks by name, see the example.</p>
		<p>If <code>nil</code> is passed as any callback, the callback will not be changed.</p>
		<p>Each callback has the following prototype:
		<pre><code class="lua">function callback(dt, shape_one, shape_two, mtv_x, mtv_y)</code></pre>
		The two <code>shape</code> parameters are the colliding shapes. The last two parameters, <code>mtv_x</code> and <code>mtv_y</code>
		define the <em>minimum translation vector</em>, i.e. the direction and magnitude shape_one has to be moved so that
		the collision will be resolved.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>function <code>start</code></dt>
				<dd>Called when two shapes start colliding.</dd>
				<dt>function <code>persist</code></dt>
				<dd>Called when two continue to collide, i.e. if the collision lasts more than one frame.</dd>
				<dt>function <code>stop</code></dt>
				<dd>Called when two shapes stop colliding.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>Nothing</dt>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">function start(dt, shape_one, shape_two, mtv_x, mtv_y)
    print('started colliding:', shape_one, shape_two)
	print('mtv:', mtv_x, mtv_y)
end

function persist_one(dt, shape_one, shape_two, mtv_x, mtv_y)
    print('still colliding:', shape_one, shape_two)
    -- move both shape_one and shape_two to resolve the collision
    shape_one:move(mtv_x/2, mtv_y/2)
    shape_two:move(-mtv_x/2, -mtv_y/2)
end

function persist_two(dt, shape_one, shape_two, mtv_x, mtv_y)
    print('still colliding:', shape_one, shape_two)
    -- move only shape_one to resolve the collision
    shape_one:move(mtv_x, mtv_y)
end

function stop(dt, shape_one, shape_two) -- ignore the translation vector
    print('collision resolved')
end

function love.load()
    hardoncollider.init(100)
    -- set initial callbacks
    hardoncollider.setCallbacks(start, persist_one, stop)
    -- change persist callback
    hardoncollider.setCallbacks{persist = persist_two}
end</code></pre>
		</div>
	</div>

	<a name="init-update"></a>
	<div id="update" class="function">
		<div class="definition">function <span class="name">update</span><span class="arglist">(dt, max_delta)</span><a class="top" href="#init">^ top</a></div>
		<p>Checks for collisions and call callbacks. Use this in <code>love.update(dt)</code>.</p>
		<p>A maximum time delta can be specified. <code>dt</code> will be chopped up in slices
		not bigger than this maximum and the scene is updated for each time slice.</p>
		<p>Note that the delta time has no effect on the collision detection itself, but
		will be passed to the callback functions.</p>
		
		<div class="arguments">Parameters:
			<dl>
				<dt>number <code>dt</code></dt>
				<dd>The time since the last update.</dd>
				<dt>number <code>max_delta</code></dt>
				<dd>Maximum time delta (see description).</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>Nothing</dt>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">function love.update(dt)
    hardoncollider.update(dt, .02)
end</code></pre>
		</div>
	</div>

	<a name="init-addPolygon"></a>
	<div id="addPolygon" class="function">
		<div class="definition">function <span class="name">addPolygon</span><span class="arglist">(x1,y1, ..., xn,yn)</span><a class="top" href="#init">^ top</a></div>
		<p>Add a polygon to the collision detection system. Any non-intersection polygon will work, even convex polygons.</p>
		<p>Note that if three consecutive points lie on a line, the middle point will be discarded. This means
		you cannot construct polygon shapes out of lines.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>numbers <code>x1,y1, ..., xn,yn</code></dt>
				<dd>The corners of the polygon. At least three corners (that do not lie on a line) are needed.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt><a href="#shape">Shape</a></dt>
				<dd>The polygon shape added to the scene.</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">shape = hardoncollider.addPolygon(10,10, 40,50, 70,10, 40,30)</code></pre>
		</div>
	</div>

	<a name="init-addRectangle"></a>
	<div id="addRectangle" class="function">
		<div class="definition">function <span class="name">addRectangle</span><span class="arglist">(x, y, w, h)</span><a class="top" href="#init">^ top</a></div>
		<p>Add a rectangle shape to the collision detection system.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>numbers <code>x, y</code></dt>
				<dd>The upper left corner of the rectangle.</dd>
				<dt>numbers <code>w, h</code></dt>
				<dd>The width and height of the rectangle.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt><a href="#shape">Shape</a></dt>
				<dd>The rectangle added to the scene.</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">rect = hardoncollider.addRectangle(100,120, 200,40)</code></pre>
		</div>
	</div>

	<a name="init-addCircle"></a>
	<div id="addCircle" class="function">
		<div class="definition">function <span class="name">addCircle</span><span class="arglist">(cx, cy, radius)</span><a class="top" href="#init">^ top</a></div>
		<p>Add a circle shape to the collision detection system.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>numbers <code>cx, cy</code></dt>
				<dd>The circle center.</dd>
				<dt>number <code>radius</code></dt>
				<dd>The circle radius.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt><a href="#shape">Shape</a></dt>
				<dd>The circle added to the scene.</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">circle = hardoncollider.addCircle(400,300, 100)</code></pre>
		</div>
	</div>

	<a name="init-remove"></a>
	<div id="remove" class="function">
		<div class="definition">function <span class="name">remove</span><span class="arglist">(shape)</span><a class="top" href="#init">^ top</a></div>
		<p>Remove a shape from the collision detection system. Note that if you remove a shape in
		the <code>start</code> or <code>persist</code> callback, other shapes might still have
		collided with it, so the shape will be argument to the other calls of <code>start</code>
		or <code>persist</code>. In any case, the <code>stop</code> callback will be called
		in the next call to <code>update</code> for each shape which the removed shape collided with.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt><a href="#shape">Shape</a> <code>shape</code></dt>
				<dd>The shape to be removed.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>Nothing</dt>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">hardoncollider.remove(circle)</code></pre>
		</div>
	</div>

	<a name="init-addToGroup"></a>
	<div id="addToGroup" class="function">
		<div class="definition">function <span class="name">addToGroup</span><span class="arglist">(group, shape, ...)</span><a class="top" href="#init">^ top</a></div>
		<p>Add shapes to a group. <a href="#shape">Shapes</a> in the same group will not collide with each other.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>string <code>group</code></dt>
				<dd>The name of the group where shapes should be added.</dd>
			</dl>
			<dl>
				<dt><a href="#shape">Shapes</a> <code>shape, ...</code></dt>
				<dd>The shapes to be added to the group.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>Nothing</dt>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">hardoncollider.addToGroup("platforms", platform1, platform2, platform3)</code></pre>
		</div>
	</div>

	<a name="init-removeFromGroup"></a>
	<div id="removeFromGroup" class="function">
		<div class="definition">function <span class="name">removeFromGroup</span><span class="arglist">(group, shape, ...)</span><a class="top" href="#init">^ top</a></div>
		<p>Remove shapes from a group.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>string <code>group</code></dt>
				<dd>The name of the group where shapes should be added.</dd>
			</dl>
			<dl>
				<dt><a href="#shape">Shapes</a> <code>shape, ...</code></dt>
				<dd>The shapes to be removed from the group.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>Nothing</dt>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">hardoncollider.removeFromGroup("platforms", not_a_platform)</code></pre>
		</div>
	</div>

	<a name="init-setGhost"></a>
	<div id="setGhost" class="function">
		<div class="definition">function <span class="name">setGhost</span><span class="arglist">(shape, ...)</span><a class="top" href="#init">^ top</a></div>
		<p>Makes a shape permeable. Ghost shapes will not collide with any other shape.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt><a href="#shape">Shapes</a> <code>shape, ...</code></dt>
				<dd>The shapes to become permeable.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>Nothing</dt>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">if cheat.set_ghost then
    hardoncollider.setGhost(player)
end</code></pre>
		</div>
	</div>

	<a name="init-setSolid"></a>
	<div id="setSolid" class="function">
		<div class="definition">function <span class="name">setSolid</span><span class="arglist">(shape, ...)</span><a class="top" href="#init">^ top</a></div>
		<p>Makes a shape opaque. <a href="#shape">Shapes</a> that were ghosts before will be subject to collision again.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt><a href="#shape">Shapes</a> <code>shape, ...</code></dt>
				<dd>The shapes to become opaque again.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>Nothing</dt>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">if cheat.set_no_ghost then
    hardoncollider.setSolid(player_recording)
end</code></pre>
		</div>
	</div>

</div>


<a name="shape"></a>
<div id="shape" class="module">
	<div class="name">hardoncollider.shape<a class="top" href="#top">^ top</a></div>

	<div class="preamble">
		<p>Shape classes with collision detection methods.</p>
		<p>This defines methods to move, rotate and draw shapes created with <code>hardoncollider.add*</code>.</p>
		<p>If you don't want to use the full blown module, you can still use these
		classes to test for colliding shapes.</p>
		<p>They might also be useful for doing GUI stuff, e.g. when testing if the
		mouse hovers a button.</p>
		<p>Some functions (<code>getAxes</code>, <code>projectOn</code>) are left
		undocumented, as they have little value outside the scope of collision detection.</p>
	</div>

	<div class="overview">
	<h3>Module overview</h3>
		<dl>
			<dt><a href="#shape-PolygonShape">PolygonShape</a></dt>
			<dd>A polygon shape.</dd>
			<dt><a href="#shape-CircleShape">CircleShape</a></dt>
			<dd>A circle shape.</dd>
			<dt><a href="#shape-shape:move">shape:move()</a></dt>
			<dd>Move the shape.</dd>
			<dt><a href="#shape-shape:rotate">shape:rotate()</a></dt>
			<dd>Rotate the shape.</dd>
			<dt><a href="#shape-shape:center">shape:center()</a></dt>
			<dd>Get the shape's center.</dd>
			<dt><a href="#shape-shape:draw">shape:draw()</a></dt>
			<dd>Draw the shape.</dd>
			<dt><a href="#shape-shape:collidesWith">shape:collidesWith()</a></dt>
			<dd>Test for collision.</dd>
		</dl>
	</div>

	<a name="shape-PolygonShape"></a>
	<div id="PolygonShape" class="class">
		<div class="constructor">class <span class="name">PolygonShape</span><span class="arglist">(x1,y1, ..., xn,yn)</span><a class="top" href="#shape">^ top</a></div>
		<div class="constructor">class <span class="name">PolygonShape</span><span class="arglist">(polygon)</span></div>
		<p>Construct a shape using a non-intersecting ploygon.</p>
		<p>You can either specify the coordinates as with <code>hardoncollider.addPolygon()</code> or use an instance of the <a href="#polygon">Polygon</a> class.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>numbers <code>x1,y1, ..., xn,yn</code></dt>
				<dd>The corners of the polygon. At least three corners (that do not lie on a line) are needed.</dd>
				<dt><a href="#polygon">Polygon</a> <code>polygon</code></dt>
				<dd>Construct the shape from this polygon.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt><a href="#shape">Shape</a></dt>
				<dd>The constructed shape.</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">shape = PolygonShape(100,100, 200,200, 300,100)</code></pre>
		</div>
	</div>

	<a name="shape-CircleShape"></a>
	<div id="CircleShape" class="class">
		<div class="constructor">class <span class="name">CircleShape</span><span class="arglist">(cx,cy, radius)</span><a class="top" href="#shape">^ top</a></div>
		<p>Construct a circular shape.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>numbers <code>cx, cy</code></dt>
				<dd>The circle center.</dd>
				<dt>number <code>radius</code></dt>
				<dd>The circle radius.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt><a href="#shape">Shape</a></dt>
				<dd>The constructed circle shape.</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">shape = CircleShape(400,300, 100)</code></pre>
		</div>
	</div>

	<a name="shape-shape:move"></a>
	<div id="shape:move" class="function">
		<div class="definition">function <span class="name">shape:move</span><span class="arglist">(x, y)</span><a class="top" href="#shape">^ top</a></div>
		<p>Move the shape.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>numbers <code>x, y</code></dt>
				<dd>The direction to move the shape in.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>Nothing</dt>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">circle:move(10,15) -- move the circle 10 units right and 15 units down</code></pre>
		</div>
	</div>

	<a name="shape-shape:rotate"></a>
	<div id="shape:rotate" class="function">
		<div class="definition">function <span class="name">shape:rotate</span><span class="arglist">(angle, cx,cy)</span><a class="top" href="#shape">^ top</a></div>
		<p>Rotate the shape. A rotation center can be specified. If no center is given, the
		shape's center is used.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>number <code>angle</code></dt>
				<dd>Amount to rotate the shape (in radians).</dd>
				<dt>numbers <code>cx, cy</code></dt>
				<dd>Rotation center. Defaults to the shape's center if omitted.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>Nothing</dt>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">rectangle:rotate(math.pi/4)</code></pre>
		</div>
	</div>

	<a name="shape-shape:center"></a>
	<div id="shape:center" class="function">
		<div class="definition">function <span class="name">shape:center</span><span class="arglist">()</span><a class="top" href="#shape">^ top</a></div>
		<p>Get the center of the shape.</p>
		<p>If the shape is a CircleShape, this is the circle center, else it's the polygon's centroid.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>None</dt>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>numbers <code>x, y</code></dt>
				<dd>The center of the shape.</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">print("Circle at:", circle:center())</code></pre>
		</div>
	</div>

	<a name="shape-shape:draw"></a>
	<div id="shape:draw" class="function">
		<div class="definition">function <span class="name">shape:draw</span><span class="arglist">(mode)</span><a class="top" href="#shape">^ top</a></div>
		<p>Draw the shape either filled or as outline.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>DrawMode <code>mode</code></dt>
				<dd>How to draw the shape. Either 'line' or 'fill'.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>Nothing</dt>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">circle:draw('fill')</code></pre>
		</div>
	</div>

	<a name="shape-shape:collidesWith"></a>
	<div id="shape:collidesWith" class="function">
		<div class="definition">function <span class="name">shape:collidesWith</span><span class="arglist">(other)</span><a class="top" href="#shape">^ top</a></div>
		<p>Test if two shapes collide.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt><a href="#shape">Shape</a> <code>other</code></dt>
				<dd>Test for collision with this shape.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>boolean <code>collide</code></dt>
				<dd><code>true</code> if the two shapes collide, <code>false</code> otherwise.</dd>
				<dt><a href="http://vrld.github.com/hump/#vector.lua">vector</a> <code>mtv</code></dt>
				<dd>The minimum translation vector, or <code>nil</code> if the two shapes don't collide.</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">if circle:collidesWith(rectangle) then
    print("collision detected!")
end</code></pre>
		</div>
	</div>

</div>


<a name="polygon"></a>
<div id="polygon" class="module">
	<div class="name">hardoncollider.polygon<a class="top" href="#top">^ top</a></div>
	<div class="preamble">
		<p>Definition of a Polygon class and implementation of some handy algorithms.</p>
		<p>On it's own, this class does not offer any collision detection. If you want that, use a PolygonShape instead.</p>
	</div>

	<div class="overview">
	<h3>Module overview</h3>
		<dl>
			<dt><a href="#polygon-Polygon">Polygon</a></dt>
			<dd>The polygon class.</dd>
			<dt><a href="#polygon-polygon:unpack">polygon:unpack()</a></dt>
			<dd>Get coordinates.</dd>
			<dt><a href="#polygon-polygon:clone">polygon:clone()</a></dt>
			<dd>Copy polygon.</dd>
			<dt><a href="#polygon-polygon:getBBox">polygon:getBBox()</a></dt>
			<dd>Get bounding box.</dd>
			<dt><a href="#polygon-polygon:isConvex">polygon:isConvex()</a></dt>
			<dd>Test if polygon is convex.</dd>
			<dt><a href="#polygon-polygon:move">polygon:move()</a></dt>
			<dd>Move polygon.</dd>
			<dt><a href="#polygon-polygon:rotate">polygon:rotate()</a></dt>
			<dd>Rotate polygon.</dd>
			<dt><a href="#polygon-polygon:triangulate">polygon:triangulate()</a></dt>
			<dd>Split polygon in triangles.</dd>
			<dt><a href="#polygon-polygon:splitConvex">polygon:splitConvex()</a></dt>
			<dd>Split polygon into convex polygons.</dd>
			<dt><a href="#polygon-polygon:mergedWith">polygon:mergedWith()</a></dt>
			<dd>Merge polygon with other polygon.</dd>
		</dl>
	</div>

	<a name="polygon-Polygon"></a>
	<div id="name" class="class">
		<div class="constructor">class <span class="name">Polygon</span><span class="arglist">(x1,y1, ..., xn,yn)</span><a class="top" href="#polygon">^ top</a></div>
		<p>Construct a polygon.</p>
		<p>At least three points that are not collinear (being on a straight line) are needed to construct the polygon.
		If there are collinear points, these points will be removed so that the overall shape of the polygon is not changed.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>numbers <code>x1,y1, ..., xn,yn</code></dt>
				<dd>The corners of the polygon. At least three corners are needed.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt><a href="#polygon">Polygon</a></dt>
				<dd>The polygon object.</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">poly = Polygon(10,10, 40,50, 70,10, 40,30)</code></pre>
		</div>
	</div>

	<a name="polygon-polygon:unpack"></a>
	<div id="polygon:unpack" class="function">
		<div class="definition">function <span class="name">polygon:unpack</span><span class="arglist">()</span><a class="top" href="#polygon">^ top</a></div>
		<p>Get the polygon's vertices. Useful for drawing with <code>love.graphics.polygon()</code>.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>None</dt>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>numbers <code>x1,y1, ..., xn,yn</code></dt>
				<dd>The vertices of the polygon.</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">love.graphics.draw('line', poly:unpack())</code></pre>
		</div>
	</div>

	<a name="polygon-polygon:clone"></a>
	<div id="polygon:clone" class="function">
		<div class="definition">function <span class="name">polygon:clone</span><span class="arglist">()</span><a class="top" href="#polygon">^ top</a></div>
		<p>Get a copy of the polygon.</p>
		<p>Since Lua uses references when simply assigning an existing polygon to a variable, unexpected things can happen when
		operating on the variable. Consider this code:</p>
		<pre><code class="lua">p1 = Polygon(10,10, 40,50, 70,10, 40,30)
p2 = p1
p3 = p1:clone()
p2:rotate(math.pi) -- p1 will be rotated, too!
p3:rotate(-math.pi) -- only p3 will be rotated</code></pre>
		<div class="arguments">Parameters:
			<dl>
				<dt>None</dt>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt><a href="#polygon">Polygon</a> <code>polygon</code></dt>
				<dd>A copy of the polygon.</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">copy = poly:clone()
copy:move(10,20)</code></pre>
		</div>
	</div>

	<a name="polygon-polygon:getBBox"></a>
	<div id="polygon:getBBox" class="function">
		<div class="definition">function <span class="name">polygon:getBBox</span><span class="arglist">()</span><a class="top" href="#polygon">^ top</a></div>
		<p>Get axis aligned bounding box.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>None</dt>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>numbers <code>x1, y1</code></dt>
				<dd>Upper left corner of the bounding box.</dd>
				<dt>numbers <code>x2, y2</code></dt>
				<dd>Lower right corner of the bounding box.</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">x1,y1,x2,y2 = poly:getBBox()
-- draw bounding box
love.graphics.rectangle('line', x1,y2, x2-x1, y2-y1)</code></pre>
		</div>
	</div>

	<a name="polygon-polygon:isConvex"></a>
	<div id="polygon:isConvex" class="function">
		<div class="definition">function <span class="name">polygon:isConvex</span><span class="arglist">()</span><a class="top" href="#polygon">^ top</a></div>
		<p>Test if a polygon is convex, i.e. a line line between any two points inside the polygon will lie in the interior of the polygon.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>None</dt>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>boolean <code>convex</code></dt>
				<dd><code>true</code> if the polygon is convex, <code>false</code> otherwise.</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">-- split into convex sub polygons
if not poly:isConvex() then
    list = poly:splitConvex()
else
    list = {poly:clone()}
end</code></pre>
		</div>
	</div>

	<a name="polygon-polygon:move"></a>
	<div id="polygon:move" class="function">
		<div class="definition">function <span class="name">polygon:move</span><span class="arglist">(x,y)</span><a class="top" href="#polygon">^ top</a></div>
		<div class="definition">function <span class="name">polygon:move</span><span class="arglist">(direction)</span></div>
		<p>Move a polygon in a direction. You can either use coordinates (<code>x, y</code>) or a <a href="http://vrld.github.com/hump/#vector.lua">hump vector</a>.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>numbers <code>x, y</code></dt>
				<dd>Coordinates of the direction to move.</dd>
				<dt><a href="http://vrld.github.com/hump/#vector.lua">vector</a> <code>direction</code></dt>
				<dd>Direction to move.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>Nothing</dt>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">poly:move(10,-5) -- move 10 units right and 5 units up</code></pre>
		</div>
	</div>

	<a name="polygon-polygon:rotate"></a>
	<div id="polygon:rotate" class="function">
		<div class="definition">function <span class="name">polygon:rotate</span><span class="arglist">(angle)</span><a class="top" href="#polygon">^ top</a></div>
		<div class="definition">function <span class="name">polygon:rotate</span><span class="arglist">(angle, cx, cy)</span></div>
		<div class="definition">function <span class="name">polygon:rotate</span><span class="arglist">(angle, center)</span></div>
		<p>Rotate the polygon. You can define a rotation center. If it is omitted, the polygon will be rotated around it's centroid.</p>
		<p>For defining a rotation center, you can either use coordinate form (<code>cx, cy</code>) or a <a href="http://vrld.github.com/hump/#vector.lua">hump vector</a>.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>number <code>angle</code></dt>
				<dd>The angle to rotate in radians.</dd>
				<dt>numbers <code>cx, cy</code></dt>
				<dd>The rotation center.</dd>
				<dt><a href="http://vrld.github.com/hump/#vector.lua">vector</a> <code>center</code></dt>
				<dd>The rotation center.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>Nothing</dt>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">p1:rotate(math.pi/2) -- rotate p1 by 90&deg; around it's center
p2:rotate(math.pi/4, 100,100) -- rotate p2 by 45&deg; around the point 100,100</code></pre>
		</div>
	</div>

	<a name="polygon-polygon:triangulate"></a>
	<div id="polygon:triangulate" class="function">
		<div class="definition">function <span class="name">polygon:triangulate</span><span class="arglist">()</span><a class="top" href="#polygon">^ top</a></div>
		<p>Split the polygon into triangles.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>None</dt>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>Array of <a href="#polygon">Polygon</a> <code>triangles</code></dt>
				<dd>Triangles that the polygon is composed of.</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">triangles = poly:triangulate()
for i,triangle in ipairs(triangles) do
    triangles.move(math.random(5,10), math.random(5,10))
end	</code></pre>
		</div>
	</div>

	<a name="polygon-polygon:splitConvex"></a>
	<div id="polygon:splitConvex" class="function">
		<div class="definition">function <span class="name">polygon:splitConvex</span><span class="arglist">()</span><a class="top" href="#polygon">^ top</a></div>
		<p>Split the polygon into convex sub polygons.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>None</dt>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>Array of <a href="#polygon">Polygon</a> <code>convex_polygons</code></dt>
				<dd>Convex polygons that form the original polygon.</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">convex = concave_polygon:splitConvex()
function love.draw()
    for i,poly in ipairs(convex) do
        love.graphics.polygon('fill', poly:unpack())
    end
end</code></pre>
		</div>
	</div>

	<a name="polygon-polygon:mergedWith"></a>
	<div id="polygon:mergedWith" class="function">
		<div class="definition">function <span class="name">polygon:mergedWith</span><span class="arglist">(other)</span><a class="top" href="#polygon">^ top</a></div>
		<p>Create a merged polygon of two polygons if, and only if the two polygons share one edge. If the polygons share more than one edge, the result may be erroneous.</p>
		<p>This function does not change either polygon, but rather create a new one.</p>
		<div class="arguments">Parameters:
			<dl>
				<dt><a href="#polygon">Polygon</a> <code>other</code></dt>
				<dd>The polygon to merge with.</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt><a href="#polygon">Polygon</a> <code>merged</code></dt>
				<dd>The merged polygon, or <code>nil</code> if the two polygons don't share an edge.</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">merged = p1:mergedWith(p2)</code></pre>
		</div>
	</div>

</div>


<a name="spatialhash"></a>
<div id="spatialhash" class="module">
	<div class="name">hardoncollider.spatialhash<a class="top" href="#top">^ top</a></div>

	<div class="preamble">
		<p>To be documented later.</p>
	</div>
<!--TODO:

	<div class="overview">
	<h3>Module overview</h3>
		<dl>
			<dt><a href="#spatialhash-Spatialhash">Spatialhash()</a></dt>
			<dd>Short description</dd>
			<dt><a href="#spatialhash-cell_meta.__newindex">cell_meta.__newindex()</a></dt>
			<dd>Short description</dd>
			<dt><a href="#spatialhash-cell_meta.__index">cell_meta.__index()</a></dt>
			<dd>Short description</dd>
			<dt><a href="#spatialhash-Spatialhash:cellCoords">Spatialhash:cellCoords()</a></dt>
			<dd>Short description</dd>
			<dt><a href="#spatialhash-Spatialhash:cell">Spatialhash:cell()</a></dt>
			<dd>Short description</dd>
			<dt><a href="#spatialhash-Spatialhash:insert">Spatialhash:insert()</a></dt>
			<dd>Short description</dd>
			<dt><a href="#spatialhash-Spatialhash:remove">Spatialhash:remove()</a></dt>
			<dd>Short description</dd>
			<dt><a href="#spatialhash-Spatialhash:update">Spatialhash:update()</a></dt>
			<dd>Short description</dd>
			<dt><a href="#spatialhash-Spatialhash:getNeighbors">Spatialhash:getNeighbors()</a></dt>
			<dd>Short description</dd>
		</dl>
	</div>

	<a name="spatialhash-Spatialhash"></a>
	<div id="Spatialhash" class="class">
		<div class="constructor"><span class="name">Spatialhash</span><span class="arglist">(cell_size)</span><a class="top" href="#spatialhash">^ top</a></div>
		<p>
		<h5 style="color:red;">Description here</h5>
		</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>[type] <code>cell_size</code></dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>[type] </dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">
				Example code
			</code></pre>
		</div>
	</div>

	<a name="spatialhash-Spatialhash:cellCoords"></a>
	<div id="Spatialhash:cellCoords" class="function">
		<div class="definition">function <span class="name">Spatialhash:cellCoords</span><span class="arglist">(v)</span><a class="top" href="#spatialhash">^ top</a></div>
		<p>
		<h5 style="color:red;">Description here</h5>
		</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>[type] <code>v</code></dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>[type] </dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">
				Example code
			</code></pre>
		</div>
	</div>

	<a name="spatialhash-Spatialhash:cell"></a>
	<div id="Spatialhash:cell" class="function">
		<div class="definition">function <span class="name">Spatialhash:cell</span><span class="arglist">(v)</span><a class="top" href="#spatialhash">^ top</a></div>
		<p>
		<h5 style="color:red;">Description here</h5>
		</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>[type] <code>v</code></dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>[type] </dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">
				Example code
			</code></pre>
		</div>
	</div>

	<a name="spatialhash-Spatialhash:insert"></a>
	<div id="Spatialhash:insert" class="function">
		<div class="definition">function <span class="name">Spatialhash:insert</span><span class="arglist">(obj, ul, lr)</span><a class="top" href="#spatialhash">^ top</a></div>
		<p>
		<h5 style="color:red;">Description here</h5>
		</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>[type] <code>obj</code></dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
				<dt>[type] <code>ul</code></dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
				<dt>[type] <code>lr</code></dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>[type] </dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">
				Example code
			</code></pre>
		</div>
	</div>

	<a name="spatialhash-Spatialhash:remove"></a>
	<div id="Spatialhash:remove" class="function">
		<div class="definition">function <span class="name">Spatialhash:remove</span><span class="arglist">(obj, ul, lr)</span><a class="top" href="#spatialhash">^ top</a></div>
		<p>
		<h5 style="color:red;">Description here</h5>
		</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>[type] <code>obj</code></dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
				<dt>[type] <code>ul</code></dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
				<dt>[type] <code>lr</code></dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>[type] </dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">
				Example code
			</code></pre>
		</div>
	</div>

	<a name="spatialhash-Spatialhash:update"></a>
	<div id="Spatialhash:update" class="function">
		<div class="definition">function <span class="name">Spatialhash:update</span><span class="arglist">(obj, ul_old, lr_old, ul_new, lr_new)</span><a class="top" href="#spatialhash">^ top</a></div>
		<p>
		<h5 style="color:red;">Description here</h5>
		</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>[type] <code>obj</code></dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
				<dt>[type] <code>ul_old</code></dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
				<dt>[type] <code>lr_old</code></dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
				<dt>[type] <code>ul_new</code></dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
				<dt>[type] <code>lr_new</code></dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>[type] </dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">
				Example code
			</code></pre>
		</div>
	</div>

	<a name="spatialhash-Spatialhash:getNeighbors"></a>
	<div id="Spatialhash:getNeighbors" class="function">
		<div class="definition">function <span class="name">Spatialhash:getNeighbors</span><span class="arglist">(obj, ul, lr)</span><a class="top" href="#spatialhash">^ top</a></div>
		<p>
		<h5 style="color:red;">Description here</h5>
		</p>
		<div class="arguments">Parameters:
			<dl>
				<dt>[type] <code>obj</code></dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
				<dt>[type] <code>ul</code></dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
				<dt>[type] <code>lr</code></dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
			</dl>
		</div>
		<div class="returns">Returns:
			<dl>
				<dt>[type] </dt>
				<dd>
				<h5 style="color:red;">Description here</h5>
				</dd>
			</dl>
		</div>
		<div class="example">Example:
			<pre><code class="lua">
				Example code
			</code></pre>
		</div>
	</div>
!-->

</div>

</body>
</html>
